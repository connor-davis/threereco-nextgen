package models

import (
	"errors"
	"time"

	"github.com/goccy/go-json"
	"github.com/gofiber/fiber/v2/log"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

// Address represents a postal or mailing location persisted in the database.
// Fields:
//
//	Id:        UUID primary key generated by the database (gen_random_uuid()).
//	LineOne:   Primary street address (e.g., street and number).
//	LineTwo:   Secondary address info (e.g., apartment, suite, unit), may be empty.
//	City:      City or locality name.
//	State:     State, province, region, or equivalent subdivision.
//	PostalCode: Numeric postal/ZIP code. Leading zeros (if any) are not preserved
//	            because the value is stored as an int; format externally if needed.
//	Country:   Country name. All string fields are stored using PostgreSQL text type.
type Address struct {
	Id         uuid.UUID `json:"id" gorm:"type:uuid;default:gen_random_uuid();primaryKey;"`
	LineOne    string    `json:"lineOne" gorm:"type:text;not null"`
	LineTwo    *string   `json:"lineTwo" gorm:"type:text"`
	City       string    `json:"city" gorm:"type:text;not null"`
	State      string    `json:"state" gorm:"type:text;not null"`
	PostalCode int       `json:"postalCode" gorm:"type:int;not null"`
	Country    string    `json:"country" gorm:"type:text;not null"`
	UserId     uuid.UUID `json:"-" gorm:"type:uuid;not null"`
	CreatedAt  time.Time `json:"createdAt" gorm:"autoCreateTime"`
	UpdatedAt  time.Time `json:"updatedAt" gorm:"autoUpdateTime"`
}

// CreateAddressPayload represents the data required to create a postal address.
// Fields:
//
//	LineOne: First address line (e.g., street address, PO box, company name).
//	LineTwo: Second address line (e.g., apartment, suite, unit, building), optional.
//	City: City or locality name.
//	State: State, province, or region code/name (format determined by business rules).
//	PostalCode: Numeric postal or ZIP code (leading zeros not preserved if present).
//	Country: ISO country name or code (business logic defines expected format).
//
// Validation considerations:
//   - PostalCode as int will drop leading zeros; use string if those must be preserved.
//   - Empty optional fields (e.g., LineTwo) should be handled gracefully upstream.
//
// Usage:
//
//	Provided as the JSON payload when creating a new address resource in the system.
type CreateAddressPayload struct {
	LineOne    string `json:"lineOne"`
	LineTwo    string `json:"lineTwo"`
	City       string `json:"city"`
	State      string `json:"state"`
	PostalCode int    `json:"postalCode"`
	Country    string `json:"country"`
}

// UpdateAddressPayload contains optional fields for partially updating an Address.
// Each field is a pointer so that nil means "no change" while a non-nil value
// replaces the existing value.
//
// Fields:
//   - LineOne, LineTwo: Street address lines.
//   - City: City or locality.
//   - State: State, province, or region/territory.
//   - PostalCode: Numeric postal or ZIP code.
//   - Country: Country identifier (recommended: ISO 3166-1 alpha-2 code).
//
// Usage: When performing an update, only set the pointers for fields you intend
// to modify; leave others nil to preserve their current values.
type UpdateAddressPayload struct {
	LineOne    *string `json:"lineOne"`
	LineTwo    *string `json:"lineTwo"`
	City       *string `json:"city"`
	State      *string `json:"state"`
	PostalCode *int    `json:"postalCode"`
	Country    *string `json:"country"`
}

// AfterCreate is a GORM hook executed after an Address has been successfully
// inserted. If the transaction does not include the key "one:ignore_audit_log",
// it will:
//  1. Retrieve the auditing user ID from the transaction context key
//     "one:audit_user_id" (returning an error if missing).
//  2. Marshal the Address instance to JSON.
//  3. Create an AuditLog entry recording the INSERT operation, associating it
//     with the Address ID and auditing user.
//
// Failures to obtain the audit user ID, marshal the Address, or persist the
// audit log are logged and returned as errors. On success, an informational
// log entry is emitted. NOTE: The AuditLog is recorded with TableName set to
// "users", which may be intentional or a potential inconsistency for address
// records.
func (a *Address) AfterCreate(tx *gorm.DB) error {
	if _, ok := tx.Get("one:ignore_audit_log"); ok {
		return nil
	}

	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	addressJSON, err := json.Marshal(a)

	if err != nil {
		log.Errorf("❌ Failed to marshal user: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "users",
		OperationType: "INSERT",
		ObjectId:      a.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          addressJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for user creation: %s", err.Error())

		return err
	}

	log.Infof("✅ Address %s created successfully with ID %s", a.LineOne, a.Id)

	return nil
}

// AfterUpdate is a GORM hook that runs after an Address has been updated.
// Unless the transaction contains the sentinel key "one:ignore_audit_log", it
// attempts to create an AuditLog entry capturing the UPDATE operation. The
// acting user's UUID must be present in the transaction under the key
// "one:audit_user_id"; if it is missing, the hook logs an error and returns one.
// The current Address value is marshaled to JSON and stored in AuditLog.Data,
// with OperationType set to "UPDATE". Any error during user ID retrieval,
// JSON marshaling, or audit log creation is logged and returned. On success,
// a structured informational log entry is emitted.
func (a *Address) AfterUpdate(tx *gorm.DB) error {
	if _, ok := tx.Get("one:ignore_audit_log"); ok {
		return nil
	}

	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	addressJSON, err := json.Marshal(a)

	if err != nil {
		log.Errorf("❌ Failed to marshal user: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "users",
		OperationType: "UPDATE",
		ObjectId:      a.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          addressJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for user update: %s", err.Error())

		return err
	}

	log.Infof("✅ Address %s updated successfully with ID %s", a.LineOne, a.Id)

	return nil
}

// BeforeDelete is a GORM hook that runs prior to deleting an Address.
// It performs audit logging unless explicitly disabled.
// Behavior:
//  1. If the transaction has the key "one:ignore_audit_log", the hook exits without logging.
//  2. Otherwise it requires "one:audit_user_id" (uuid.UUID) in the transaction context; if absent, it returns an error and aborts deletion.
//  3. It marshals the current Address into JSON and creates an AuditLog entry with OperationType "DELETE" and ObjectId set to the Address ID.
//  4. Any failure (missing audit user ID, JSON marshal error, or audit log persistence error) returns an error and prevents the delete.
//
// Notes:
//   - The AuditLog TableName is hard-coded as "users", which may be intentional or a possible inconsistency for an address deletion.
//   - On success it emits an informational log confirming the deletion.
//
// Returns nil on success or an error to halt the delete operation.
func (a *Address) BeforeDelete(tx *gorm.DB) error {
	if _, ok := tx.Get("one:ignore_audit_log"); ok {
		return nil
	}

	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	addressJSON, err := json.Marshal(a)

	if err != nil {
		log.Errorf("❌ Failed to marshal user: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "users",
		OperationType: "DELETE",
		ObjectId:      a.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          addressJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for user deletion: %s", err.Error())

		return err
	}

	log.Infof("✅ Address %s deleted successfully with ID %s", a.LineOne, a.Id)

	return nil
}
