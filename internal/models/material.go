package models

import (
	"errors"
	"time"

	"github.com/goccy/go-json"
	"github.com/gofiber/fiber/v2/log"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

// Material represents a material entity tracked within the system.
// It includes identification, descriptive, relational, and audit metadata:
//   - Id: Unique UUID primary key (auto-generated by the database).
//   - Name: Human-readable material name (required).
//   - GwCode: Integer-based external or gateway code identifier (required).
//   - CarbonFactor: Textual representation of the material's carbon emission factor (required).
//   - Products: Many-to-many relationship to Product entities (joins via products_materials; cascades on delete).
//   - Organizations: Many-to-many relationship to Organization entities (joins via organizations_materials; cascades on delete).
//   - CreatedAt: Timestamp automatically set when the record is first created.
//   - UpdatedAt: Timestamp automatically updated on each modification.
//
// The struct leverages GORM tags for schema definition, UUID generation, and relationship management.
type Material struct {
	Id               uuid.UUID `json:"id" gorm:"type:uuid;default:gen_random_uuid();primaryKey;"`
	Name             string    `json:"name" gorm:"type:text;not null;"`
	GwCode           string    `json:"gwCode" gorm:"type:text;not null;"`
	CarbonFactor     string    `json:"carbonFactor" gorm:"type:text;not null;"`
	Products         []Product `json:"-" gorm:"many2many:products_materials;constraint:OnDelete:CASCADE;"`
	ModifiedByUserId uuid.UUID `json:"modifiedById" gorm:"type:uuid;"`
	ModifiedByUser   *User     `json:"modifiedBy,omitzero"`
	CreatedAt        time.Time `json:"createdAt" gorm:"autoCreateTime;"`
	UpdatedAt        time.Time `json:"updatedAt" gorm:"autoUpdateTime;"`
}

// CreateMaterialPayload represents the JSON body used to create a new material.
// Fields:
//   - Name: Human‑readable material name (required).
//   - GwCode: Integer code identifying the material (required).
//   - CarbonFactor: Emission / carbon factor associated with the material, stored as text (required).
type CreateMaterialPayload struct {
	Name         string `json:"name" gorm:"type:text;not null;"`
	GwCode       string `json:"gwCode" gorm:"type:text;not null;"`
	CarbonFactor string `json:"carbonFactor" gorm:"type:text;not null;"`
}

// UpdateMaterialPayload represents the optional fields that can be modified when updating a Material.
// Each field is a pointer so that a nil value means "leave unchanged", while a non-nil value (even an empty string)
// indicates an explicit update request.
// Fields:
//
//	Name: Human-readable name of the material.
//	GwCode: Code referencing the material's GW classification or external system identifier.
//	CarbonFactor: Emissions factor (e.g., CO₂e per unit), stored as text to allow flexible formatting.
type UpdateMaterialPayload struct {
	Name         *string `json:"name" gorm:"type:text;not null;"`
	GwCode       *string `json:"gwCode" gorm:"type:text;not null;"`
	CarbonFactor *string `json:"carbonFactor" gorm:"type:text;not null;"`
}

// AfterCreate is a GORM hook that is triggered after a Material record is created in the database.
// It retrieves the audit user ID from the transaction context, marshals the Material object to JSON,
// and creates an audit log entry recording the creation event. If any step fails, it logs the error
// and returns it to GORM, which may abort the transaction.
func (m *Material) AfterCreate(tx *gorm.DB) error {
	if _, ok := tx.Get("one:ignore_audit_log"); ok {
		return nil
	}

	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	materialJSON, err := json.Marshal(m)

	if err != nil {
		log.Errorf("❌ Failed to marshal material: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "materials",
		OperationType: "INSERT",
		ObjectId:      m.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          materialJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for material creation: %s", err.Error())

		return err
	}

	log.Infof("✅ Material %s created successfully with ID %s", m.Name, m.Id)

	return nil
}

// AfterUpdate is a GORM hook that is triggered after a Material record is updated.
// It retrieves the audit user ID from the transaction context, marshals the updated Material
// into JSON, and creates an audit log entry recording the update operation.
func (m *Material) AfterUpdate(tx *gorm.DB) error {
	if _, ok := tx.Get("one:ignore_audit_log"); ok {
		return nil
	}

	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	materialJSON, err := json.Marshal(m)

	if err != nil {
		log.Errorf("❌ Failed to marshal material: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "materials",
		OperationType: "UPDATE",
		ObjectId:      m.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          materialJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for material update: %s", err.Error())

		return err
	}

	log.Infof("✅ Material %s updated successfully with ID %s", m.Name, m.Id)

	return nil
}

// BeforeDelete is a GORM hook that is triggered before a Material record is deleted.
// It retrieves the audit user ID from the transaction context, marshals the Material object to JSON,
// and creates an audit log entry recording the deletion event. If any step fails, it logs the error
// and returns it to GORM, which may abort the transaction.
func (m *Material) BeforeDelete(tx *gorm.DB) error {
	if _, ok := tx.Get("one:ignore_audit_log"); ok {
		return nil
	}

	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	materialJSON, err := json.Marshal(m)

	if err != nil {
		log.Errorf("❌ Failed to marshal material: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "materials",
		OperationType: "DELETE",
		ObjectId:      m.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          materialJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for material deletion: %s", err.Error())

		return err
	}

	log.Infof("✅ Material %s deleted successfully with ID %s", m.Name, m.Id)

	return nil
}
