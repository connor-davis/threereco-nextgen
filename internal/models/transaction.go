package models

import (
	"errors"
	"time"

	"github.com/goccy/go-json"
	"github.com/gofiber/fiber/v2/log"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

type TransactionType string

const (
	TransactionTypeCollection TransactionType = "collection"
	TransactionTypeTransfer   TransactionType = "transfer"
)

// Transaction models a trade recorded between a seller and a buyer.
// It stores monetary and weight totals, the seller’s response state,
// party identifiers (with type discriminators), the related products,
// and auditing timestamps. The record uses a UUID primary key and GORM
// constraints/defaults to ensure data integrity.
//
// Fields:
//   - Id: UUID primary key generated by the database (uuid_generate_v4).
//   - Type: Classification of the transaction (see TransactionType).
//   - Weight: Total weight of all products; decimal with 2 fractional digits (default 0.00).
//   - Amount: Total monetary value; decimal with 2 fractional digits (default 0.00).
//   - SellerAccepted: Flag indicating the seller has accepted the transaction.
//   - SellerDeclined: Flag indicating the seller has declined the transaction.
//     Note: At most one of SellerAccepted or SellerDeclined should be true.
//   - SellerID / SellerType: Polymorphic reference identifying the seller entity.
//   - BuyerID / BuyerType: Polymorphic reference identifying the buyer entity.
//   - Products: Many-to-many association to Product via transactions_products; cascades on delete.
//   - CreatedAt / UpdatedAt: Timestamps automatically managed by GORM.
type Transaction struct {
	Id             uuid.UUID       `json:"id" gorm:"type:uuid;default:uuid_generate_v4();primaryKey;"`
	Type           TransactionType `json:"type" gorm:"type:text;not null;"`
	Weight         float64         `json:"weight" gorm:"type:decimal(10,2);not null;default:0.0;"`
	Amount         float64         `json:"amount" gorm:"type:decimal(10,2);not null;default:0.0;"`
	SellerAccepted bool            `json:"sellerAccepted" gorm:"type:boolean;not null;default:false;"`
	SellerDeclined bool            `json:"sellerDeclined" gorm:"type:boolean;not null;default:false;"`
	SellerID       uuid.UUID       `json:"sellerId" gorm:"type:uuid;not null;"`
	SellerType     string          `json:"sellerType" gorm:"type:text;not null;"`
	BuyerID        uuid.UUID       `json:"buyerId" gorm:"type:uuid;not null;"`
	BuyerType      string          `json:"buyerType" gorm:"type:text;not null;"`
	Products       []Product       `json:"products" gorm:"many2many:transactions_products;constraint:OnDelete:CASCADE;"`
	CreatedAt      time.Time       `json:"createdAt" gorm:"autoCreateTime;"`
	UpdatedAt      time.Time       `json:"updatedAt" gorm:"autoUpdateTime;"`
}

// CreateTransactionPayload defines the JSON request body used to create a new transaction.
// It captures the transaction type, aggregate weight and amount, the participating parties,
// and the list of products involved.
//
// Fields (JSON name → type):
// - "type" → TransactionType: Required; specifies the kind of transaction.
// - "weight" → float64: Required; total weight of the products in the transaction.
// - "amount" → float64: Required; monetary total for the transaction.
// - "sellerId" → uuid.UUID: Required; unique identifier of the seller.
// - "buyerId" → uuid.UUID: Required; unique identifier of the buyer.
// - "products" → []Product: Required; the items included in the transaction.
//
// All fields are validated as required via binding tags. UUID fields must be valid UUIDs.
type CreateTransactionPayload struct {
	Type     TransactionType `json:"type" binding:"required"`
	Weight   float64         `json:"weight" binding:"required"`
	Amount   float64         `json:"amount" binding:"required"`
	SellerID uuid.UUID       `json:"sellerId" binding:"required"`
	BuyerID  uuid.UUID       `json:"buyerId" binding:"required"`
	Products []Product       `json:"products" binding:"required"`
}

// UpdateTransactionPayload represents a partial update (PATCH) request for a Transaction.
// Pointer fields are optional; when a pointer is nil, that field is left unchanged.
// When provided, values replace the corresponding fields on the target transaction.
// Fields:
//   - Type: new transaction classification.
//   - Weight: updated total weight of the transaction.
//   - Amount: updated monetary amount.
//   - SellerID, BuyerID: identifiers of the parties involved; may be used for reassignment or validation.
//   - SellerAccepted, SellerDeclined: flags to update the seller’s response state.
//   - Products: list of products to associate with the transaction. A nil slice typically means “no change”,
//     while a non-nil slice (including empty) replaces the existing set.
type UpdateTransactionPayload struct {
	Type           *TransactionType `json:"type"`
	Weight         *float64         `json:"weight"`
	Amount         *float64         `json:"amount"`
	SellerID       uuid.UUID        `json:"sellerId"`
	BuyerID        uuid.UUID        `json:"buyerId"`
	SellerAccepted *bool            `json:"sellerAccepted"`
	SellerDeclined *bool            `json:"sellerDeclined"`
	Products       []Product        `json:"products"`
}

// AfterCreate is a GORM hook invoked after a Transaction has been inserted.
// It retrieves the audit user ID from the DB context key "one:audit_user_id",
// serializes the Transaction to JSON, and records an AuditLog entry with
// OperationType "INSERT" for the "transactions" table, including the Transaction
// ID and user ID. If the audit user ID cannot be obtained, JSON marshaling fails,
// or the audit log cannot be created, it logs the error and returns it; otherwise,
// it logs a success message and returns nil.
func (t *Transaction) AfterCreate(tx *gorm.DB) error {
	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	transactionJSON, err := json.Marshal(t)

	if err != nil {
		log.Errorf("❌ Failed to marshal transaction: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "transactions",
		OperationType: "INSERT",
		ObjectId:      t.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          transactionJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for transaction creation: %s", err.Error())

		return err
	}

	log.Infof("✅ Transaction %s created successfully with ID %s", t.Type, t.Id)

	return nil
}

// AfterUpdate is a GORM hook invoked after a Transaction is successfully updated.
// It retrieves the acting user's UUID from tx using the key "one:audit_user_id",
// serializes the updated transaction to JSON, and writes an AuditLog record
// for the "transactions" table with operation type "UPDATE".
// Returns an error if the audit user ID is missing, JSON marshaling fails,
// or persisting the audit log fails. Emits diagnostic logs for both failures
// and success. This method is called automatically by GORM and should not be
// invoked directly.
func (t *Transaction) AfterUpdate(tx *gorm.DB) error {
	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	transactionJSON, err := json.Marshal(t)

	if err != nil {
		log.Errorf("❌ Failed to marshal transaction: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "transactions",
		OperationType: "UPDATE",
		ObjectId:      t.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          transactionJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for transaction update: %s", err.Error())

		return err
	}

	log.Infof("✅ Transaction %s updated successfully with ID %s", t.Type, t.Id)

	return nil
}

// AfterDelete is a GORM hook that runs after a Transaction is deleted.
// It retrieves the auditing user ID from the DB session context (key "one:audit_user_id"),
// marshals the deleted Transaction into JSON, and creates an AuditLog entry for the
// "transactions" table with operation type "DELETE" and the deleted record's ID.
// The method returns an error if the audit user ID is missing, JSON marshaling fails,
// or the audit log record cannot be persisted. It also emits logs for both failures
// and a success message including the transaction title and ID.
func (t *Transaction) AfterDelete(tx *gorm.DB) error {
	auditUserId, ok := tx.Get("one:audit_user_id")

	if !ok {
		log.Errorf("❌ Failed to get audit user ID")

		return errors.New("failed to get audit user ID")
	}

	transactionJSON, err := json.Marshal(t)

	if err != nil {
		log.Errorf("❌ Failed to marshal transaction: %s", err.Error())

		return err
	}

	auditLog := &AuditLog{
		TableName:     "transactions",
		OperationType: "DELETE",
		ObjectId:      t.Id,
		UserId:        auditUserId.(uuid.UUID),
		Data:          transactionJSON,
	}

	if err := tx.Create(auditLog).Error; err != nil {
		log.Errorf("❌ Failed to create audit log for transaction deletion: %s", err.Error())

		return err
	}

	log.Infof("✅ Transaction %s deleted successfully with ID %s", t.Type, t.Id)

	return nil
}
